{{~#*inline "fieldsClass" ~}}
{{ multilineComment description }}
@immutable
class {{ className }} {{ classExtends baseType='Equatable' interfaces=(wrapFields interfaces) }} {

  {{#each fields}}{{#if type}}{{#if name}}
  {{#if description }}{{ multilineComment description }}
  {{/if}}
  {{ resolveType type
      "final"
      (takeFirst contextName ../contextName)
      (takeFirst contextModels ../contextModels)
      isArray
      raw
      ../name
  }} {{ dartName name }};
  {{~/if}}{{/if}}{{/each}}

  const {{ className }}({
    {{#each fields}}{{#if name}}
      this.{{ dartName name }},
    {{/if}}{{/each}}
  });

  @override
  List<Object> get props => [
    {{~#each fields}}{{#if name}}
    {{ dartName name }},
    {{/if}}{{/each~}}
  ];

  /// Creates a new `{{ className }}` with non-null values from [other] as attribute overrides
  {{ className }} mergedLeftWith(covariant {{ className }} other) {
    assert(other != null, "$this Cannot be merged with null");
    return {{ className }}(
      {{~#each fields}}{{#if name}}
      {{ dartName name }}: other.{{ dartName name }} ?? {{ dartName name }},
      {{/if}}{{/each~}}
    );
  }

  /// Creates a new `{{ className }}` with non-null values from [other] as attribute defaults
  {{ className }} mergedRightWith(covariant {{ className }} other) {
    assert(other != null, "$this Cannot be merged with null");
    return other.mergedLeftWith(this);
  }
    
}
{{~/inline~}}

{{#unless (
  ignoreType
    name
      @root.config.replaceTypes
      typeName
      @root.config.irreducibleTypes
)}}

{{> fieldsClass this className=(concat "_" name "Fields") }}

{{ multilineComment description }}
@immutable
class {{ name }} {{ classExtends baseType='Equatable' interfaces=interfaces }} {
  static final String typeName = "{{ takeFirst typeName name }}";

  @protected
  final _{{ name }}Fields fields;

  const {{name}}._fromFields(this.fields);

  {{name}}(
    {{#emptySafeEach fields
      required='name'
      prefix='{'
      delimiter=','
      suffix=', }'
    }}
      {{ resolveType type
        "inline"
        (takeFirst contextName ../contextName)
        (takeFirst contextModels ../contextModels)
        isArray
        raw
        ../name
      }} {{ dartName name }}
    {{/emptySafeEach}}
  ): fields = _{{ name }}Fields(
    {{#each fields}}
    {{ dartName name }}: {{ dartName name }},
    {{/each}}
  );

  @override
  List<Object> get props => [fields];

  {{!-- not sure why but this breaks things 
  /// Creates a new `{{ name }}` with the given non-null values overridden
  {{ name }} copyWith({{#emptySafeEach fields required='name' excluding='__typename' prefix='{' suffix='}'}}
      {{ resolveType type
          "inline"
          (takeFirst contextName ../contextName)
          (takeFirst contextModels ../contextModels)
          isArray
          raw
          ../name
      }} {{ dartName name }},
  {{/emptySafeEach}}) => {{ name }}(
    {{~#each fields}}
    {{ dartName name }}: {{ dartName name }} ?? this.{{ dartName name }},
    {{/each~}}
  );
  --}}


  /// Creates a new `{{ name }}` with non-null values from [other] as attribute overrides
  {{ name }} mergedLeftWith(covariant {{ name }} other) =>
    {{ name }}._fromFields(fields.mergedLeftWith(other.fields));

  /// Creates a new `{{ name }}` with non-null values from [other] as attribute defaults
  {{ name }} mergedRightWith(covariant {{ name }} other) =>
    {{ name }}._fromFields(fields.mergedRightWith(other.fields));

  /// Alias for [mergedLeftWith]
  {{ name }} operator <<(covariant {{ name }} other) => mergedLeftWith(other);

  /// Alias for [mergedRightWith]
  {{ name }} operator >>(covariant {{ name }} other) => mergedRightWith(other);

  @protected
  Set<String> get missingRequiredFields {
    Set<String> missingFields = Set();
    {{#each fields}}
    {{~#if isRequired}}
    if (fields.{{ dartName name }} == null){
        missingFields.add("{{ dartName name }}");
    }
    {{/if}}
    {{/each}}
    return missingFields;
  }

  void validate(){
    final missing = missingRequiredFields;
    assert(missing.isEmpty, "$runtimeType#$hashCode is missing required fields $missing"); 
  }

  bool get isValid => missingRequiredFields.isEmpty;

}

{{/unless}}